-- StarterPlayerScripts/AutoFarmTools_Sync.client.lua
-- 2 tombol: Auto Coin + Auto Finish
-- Sinkronisasi diperbaiki: settle TP, dance di START_POS, confetti "baru", dan portal Hitbox (nama persis)

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService        = game:GetService("RunService")
local TweenService      = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local UserInputService  = game:GetService("UserInputService")

local LP = Players.LocalPlayer

-- ====== KONFIG ======
local START_POS        = Vector3.new(-782.0, 97.2, 1298.0)
local STEP_DIST        = 8
local MOVE_TIME        = 0.30      -- sedikit lebih lambat agar stabil
local BETWEEN_TWEENS   = 0.05
local COIN_INTERVAL    = 0.35
local COIN_ABOVE       = 3
local CONFETTI_TIMEOUT = 10
local CONFETTI_MIN_NEW = 5         -- minimal pertambahan child agar dianggap confetti baru
local START_TOLERANCE  = 6         -- harus sedekat ini dari START_POS untuk mulai dance

local PORTAL_PATH = {"Ending","Portal","Portal"} -- folder berisi banyak Hitbox
local HITBOX_NAME = "Hitbox"                     -- nama persis

-- ====== UTIL ======
local function waitForCharacter()
    if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then return end
    LP.CharacterAdded:Wait()
    LP.Character:WaitForChild("HumanoidRootPart")
end

local function HRP()
    local char = LP.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function dist(a, b) return (a - b).Magnitude end

local function tpCFrame(cf)
    waitForCharacter()
    local hrp = HRP(); if not hrp then return false end
    hrp.CFrame = cf
    return true
end

local function tpVector3(v) return tpCFrame(CFrame.new(v)) end

local function tweenTo(cfTo, t)
    local hrp = HRP(); if not hrp then return false end
    local tw = TweenService:Create(hrp, TweenInfo.new(t or MOVE_TIME, Enum.EasingStyle.Linear), {CFrame = cfTo})
    tw:Play(); tw.Completed:Wait()
    return true
end

-- ====== RemoteFunction PickupCoin (cari dinamis) ======
local function findPickupRF()
    local f = ReplicatedStorage:FindFirstChild("RemoteFunctions")
    if f then
        local rf = f:FindFirstChild("PickupCoin")
        if rf and rf:IsA("RemoteFunction") then return rf end
    end
    for _, d in ipairs(ReplicatedStorage:GetDescendants()) do
        if d:IsA("RemoteFunction") and d.Name == "PickupCoin" then
            return d
        end
    end
    return nil
end
local pickupRF = findPickupRF()

-- ====== Coin helpers ======
local function getCoinModels()
    local t = {}
    local folder = workspace:FindFirstChild("PickupCoin")
    if folder then
        for _, m in ipairs(folder:GetChildren()) do
            if m:IsA("Model") then table.insert(t, m) end
        end
    end
    for _, m in ipairs(CollectionService:GetTagged("Coin")) do
        if m:IsA("Model") then table.insert(t, m) end
    end
    return t
end

local function modelPivotCF(model)
    local root = model:FindFirstChild("Root") or model.PrimaryPart
    if root then return root.CFrame end
    if model.GetPivot then return model:GetPivot() end
    return nil
end

-- ====== Confetti detector: hanya hitung confetti BARU di siklus ini ======
local function snapshotConfettiCount()
    local pg  = LP:WaitForChild("PlayerGui")
    local gui = pg:FindFirstChild("ConfettiGui")
    return gui and #gui:GetChildren() or 0
end

local function waitConfettiNew(timeout, baseCount)
    local pg = LP:WaitForChild("PlayerGui")
    local t0 = os.clock()
    while (os.clock() - t0) < (timeout or CONFETTI_TIMEOUT) do
        local gui = pg:FindFirstChild("ConfettiGui")
        if gui then
            local now = #gui:GetChildren()
            if (now - baseCount) >= CONFETTI_MIN_NEW then
                return true
            end
        end
        task.wait(0.05)
    end
    return false
end

-- ====== Portal Hitbox ======
local function getPortalFolder()
    local cur = workspace
    for _, name in ipairs(PORTAL_PATH) do
        cur = cur:FindFirstChild(name)
        if not cur then return nil end
    end
    return cur
end

local function findNearestHitboxCF()
    local container = getPortalFolder()
    if not container then return nil end
    local hrp = HRP(); if not hrp then return nil end
    local bestCF, bestDist
    for _, d in ipairs(container:GetDescendants()) do
        if d:IsA("BasePart") and d.Name == HITBOX_NAME then
            local dd = (d.Position - hrp.Position).Magnitude
            if not bestDist or dd < bestDist then
                bestDist, bestCF = dd, d.CFrame
            end
        end
    end
    return bestCF
end

-- ====== AUTO COIN ======
local function doAutoCoinStep()
    if not pickupRF then return end
    for _, coin in ipairs(getCoinModels()) do
        if coin.Parent then
            local cf = modelPivotCF(coin)
            if cf then
                tpCFrame(cf + Vector3.new(0, COIN_ABOVE, 0))
                task.wait(0.10)
                pcall(function() pickupRF:InvokeServer(coin) end)
                task.wait(COIN_INTERVAL)
            end
        end
    end
end

-- ====== AUTO FINISH ======
local function ensureAtStart()
    -- TP sampai benar-benar dekat START_POS
    for _ = 1, 5 do
        tpVector3(START_POS)
        task.wait(0.20)
        local hrp = HRP()
        if hrp and dist(hrp.Position, START_POS) <= START_TOLERANCE then
            return true
        end
    end
    return false
end

local function doAutoFinishCycle()
    if not ensureAtStart() then return end

    local hrp = HRP(); if not hrp then return end
    -- snapshot confetti awal (supaya cuma tangkap yang BARU)
    local baseCount = snapshotConfettiCount()

    local baseCF = hrp.CFrame
    local look   = baseCF.LookVector
    local fwdCF  = baseCF + (look * STEP_DIST)
    local bakCF  = baseCF - (look * STEP_DIST)

    local t0 = os.clock()
    while (os.clock() - t0) < CONFETTI_TIMEOUT do
        -- selalu pastikan tetap dekat start; kalau meleset (respawn/ketarik), balik
        if dist(HRP().Position, START_POS) > (START_TOLERANCE + 2) then
            if not ensureAtStart() then break end
            baseCF = HRP().CFrame
            look   = baseCF.LookVector
            fwdCF  = baseCF + (look * STEP_DIST)
            bakCF  = baseCF - (look * STEP_DIST)
        end

        tweenTo(fwdCF)
        task.wait(BETWEEN_TWEENS)
        if waitConfettiNew(0.01, baseCount) then break end

        tweenTo(bakCF)
        task.wait(BETWEEN_TWEENS)
        if waitConfettiNew(0.01, baseCount) then break end
    end

    -- ke portal (Hitbox persis)
    local portalCF = findNearestHitboxCF()
    if portalCF then
        tpCFrame(portalCF + Vector3.new(0, 3, 0))
        task.wait(0.25)
    end
end

-- ====== GUI ======
local screen = Instance.new("ScreenGui")
screen.Name = "AutoToolsUI"
screen.ResetOnSpawn = false
screen.Parent = LP:WaitForChild("PlayerGui")

local function makeBtn(label, x, y)
    local b = Instance.new("TextButton")
    b.Size = UDim2.fromOffset(200, 44)
    b.Position = UDim2.new(0, x, 0, y)
    b.BackgroundTransparency = 0.1
    b.TextScaled = true
    b.Text = label
    b.Parent = screen
    local c = Instance.new("UICorner"); c.CornerRadius = UDim.new(0, 8); c.Parent = b
    return b
end

local btnCoin   = makeBtn("Auto Coin: OFF",   20, 70)
local btnFinish = makeBtn("Auto Finish: OFF", 20, 120)

local autoCoinOn, autoFinishOn = false, false
local function setVisual(btn, on, prefix)
    btn.Text = prefix .. (on and "ON" or "OFF")
    btn.BackgroundColor3 = on and Color3.fromRGB(110,220,140) or Color3.fromRGB(220,130,130)
end
setVisual(btnCoin,   false, "Auto Coin: ")
setVisual(btnFinish, false, "Auto Finish: ")

local function turnCoin(on)
    autoCoinOn = on
    setVisual(btnCoin, autoCoinOn, "Auto Coin: ")
end

local function turnFinish(on)
    autoFinishOn = on
    setVisual(btnFinish, autoFinishOn, "Auto Finish: ")
    if on then
        -- demi stabilitas: matikan Auto Coin saat Auto Finish aktif
        if autoCoinOn then turnCoin(false) end
    end
end

btnCoin.MouseButton1Click:Connect(function() turnCoin(not autoCoinOn) end)
btnFinish.MouseButton1Click:Connect(function() turnFinish(not autoFinishOn) end)

-- Shortcut: RightShift (Auto Coin), RightCtrl (Auto Finish)
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        turnCoin(not autoCoinOn)
    elseif input.KeyCode == Enum.KeyCode.RightControl then
        turnFinish(not autoFinishOn)
    end
end)

-- ====== Loops ======
task.spawn(function()
    while true do
        if autoCoinOn then doAutoCoinStep() end
        task.wait(0.05)
    end
end)

task.spawn(function()
    while true do
        if autoFinishOn then doAutoFinishCycle() end
        task.wait(0.05)
    end
end)
