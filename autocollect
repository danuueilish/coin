-- StarterPlayerScripts/AutoFarmTools_HitboxOnly.client.lua
-- 2 tombol: Auto Coin + Auto Finish
-- Auto Finish hanya teleport ke part bernama persis "Hitbox" (bukan Hitbox1, Hitbox2, dst)

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService        = game:GetService("RunService")
local TweenService      = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local UserInputService  = game:GetService("UserInputService")

local LP = Players.LocalPlayer

-- ========= KONFIG =========
local START_POS       = Vector3.new(-782.0, 97.2, 1298.0)
local STEP_DIST       = 8
local MOVE_TIME       = 0.25
local COIN_INTERVAL   = 0.40
local COIN_ABOVE      = 3
local CONFETTI_TIMEOUT= 10
local CONFETTI_MIN_CHILDREN = 40
local PORTAL_PATH = {"Ending","Portal","Portal"} -- folder berisi Hitbox

-- ========= UTIL =========
local function HRP()
    local char = LP.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function tpCFrame(cf)
    local hrp = HRP(); if not hrp then return false end
    hrp.CFrame = cf; return true
end

local function tpVector3(v)
    return tpCFrame(CFrame.new(v))
end

local function tweenTo(cfTo, t)
    local hrp = HRP(); if not hrp then return false end
    local tw = TweenService:Create(hrp, TweenInfo.new(t or MOVE_TIME, Enum.EasingStyle.Linear), {CFrame = cfTo})
    tw:Play(); tw.Completed:Wait(); return true
end

-- ========= PickupCoin RF =========
local function findPickupRF()
    local folder = ReplicatedStorage:FindFirstChild("RemoteFunctions")
    if folder then
        local rf = folder:FindFirstChild("PickupCoin")
        if rf and rf:IsA("RemoteFunction") then return rf end
    end
    for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
        if obj:IsA("RemoteFunction") and obj.Name == "PickupCoin" then
            return obj
        end
    end
    return nil
end
local pickupRF = findPickupRF()

-- ========= Coin list =========
local function getCoinModels()
    local t = {}
    local folder = workspace:FindFirstChild("PickupCoin")
    if folder then
        for _, m in ipairs(folder:GetChildren()) do
            if m:IsA("Model") then table.insert(t, m) end
        end
    end
    for _, m in ipairs(CollectionService:GetTagged("Coin")) do
        if m:IsA("Model") then table.insert(t, m) end
    end
    return t
end

local function modelPivotCF(model)
    local root = model:FindFirstChild("Root") or model.PrimaryPart
    if root then return root.CFrame end
    if model.GetPivot then return model:GetPivot() end
    return nil
end

-- ========= Confetti detector =========
local confettiFlag = false
local function setupConfettiWatch()
    confettiFlag = false
    local pg = LP:WaitForChild("PlayerGui")

    pg.ChildAdded:Connect(function(ch)
        if ch.Name == "ConfettiGui" then
            confettiFlag = true
        end
    end)

    task.spawn(function()
        while true do
            local gui = pg:FindFirstChild("ConfettiGui")
            if gui and #gui:GetChildren() >= CONFETTI_MIN_CHILDREN then
                confettiFlag = true
            end
            task.wait(0.05)
        end
    end)
end
setupConfettiWatch()

local function waitConfetti(timeout)
    local t0 = os.clock()
    while (os.clock() - t0) < (timeout or CONFETTI_TIMEOUT) do
        if confettiFlag then confettiFlag = false; return true end
        task.wait(0.05)
    end
    return false
end

-- ========= Cari Hitbox persis =========
local function getPortalFolder()
    local cur = workspace
    for _, name in ipairs(PORTAL_PATH) do
        cur = cur:FindFirstChild(name)
        if not cur then return nil end
    end
    return cur
end

local function findHitboxCF()
    local container = getPortalFolder()
    if not container then return nil end
    local hrp = HRP(); if not hrp then return nil end
    local bestCF, bestDist
    for _, d in ipairs(container:GetDescendants()) do
        if d:IsA("BasePart") and d.Name == "Hitbox" then
            local dist = (d.Position - hrp.Position).Magnitude
            if not bestDist or dist < bestDist then
                bestDist, bestCF = dist, d.CFrame
            end
        end
    end
    return bestCF
end

-- ========= AUTO COIN =========
local function doAutoCoinStep()
    if not pickupRF then return end
    for _, coin in ipairs(getCoinModels()) do
        if coin.Parent then
            local cf = modelPivotCF(coin)
            if cf then
                tpCFrame(cf + Vector3.new(0, COIN_ABOVE, 0))
                task.wait(0.10)
                pcall(function() pickupRF:InvokeServer(coin) end)
                task.wait(COIN_INTERVAL)
            end
        end
    end
end

-- ========= AUTO FINISH =========
local function doAutoFinishCycle()
    tpVector3(START_POS)
    task.wait(0.15)

    local hrp = HRP(); if not hrp then return end
    local baseCF = hrp.CFrame
    local look   = baseCF.LookVector
    local fwdCF  = baseCF + (look * STEP_DIST)
    local bakCF  = baseCF - (look * STEP_DIST)

    local t0 = os.clock()
    while (os.clock() - t0) < CONFETTI_TIMEOUT do
        tweenTo(fwdCF)
        if confettiFlag then confettiFlag = false break end
        tweenTo(bakCF)
        if confettiFlag then confettiFlag = false break end
        if waitConfetti(0.01) then break end
    end

    local portalCF = findHitboxCF()
    if portalCF then
        tpCFrame(portalCF + Vector3.new(0, 3, 0))
        task.wait(0.25)
    end
end

-- ========= GUI =========
local screen = Instance.new("ScreenGui")
screen.Name = "AutoToolsUI"
screen.ResetOnSpawn = false
screen.Parent = LP:WaitForChild("PlayerGui")

local function makeBtn(label, x, y)
    local b = Instance.new("TextButton")
    b.Size = UDim2.fromOffset(200, 44)
    b.Position = UDim2.new(0, x, 0, y)
    b.BackgroundTransparency = 0.1
    b.TextScaled = true
    b.Text = label
    b.Parent = screen
    local c = Instance.new("UICorner"); c.CornerRadius = UDim.new(0, 8); c.Parent = b
    return b
end

local btnCoin   = makeBtn("Auto Coin: OFF",   20, 70)
local btnFinish = makeBtn("Auto Finish: OFF", 20, 120)

local autoCoinOn, autoFinishOn = false, false
local function setVisual(btn, on, prefix)
    btn.Text = prefix .. (on and "ON" or "OFF")
    btn.BackgroundColor3 = on and Color3.fromRGB(110,220,140) or Color3.fromRGB(220,130,130)
end
setVisual(btnCoin,   false, "Auto Coin: ")
setVisual(btnFinish, false, "Auto Finish: ")

btnCoin.MouseButton1Click:Connect(function()
    autoCoinOn = not autoCoinOn
    setVisual(btnCoin, autoCoinOn, "Auto Coin: ")
end)

btnFinish.MouseButton1Click:Connect(function()
    autoFinishOn = not autoFinishOn
    setVisual(btnFinish, autoFinishOn, "Auto Finish: ")
end)

-- Shortcut: RightShift untuk Auto Coin, RightCtrl untuk Auto Finish
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        autoCoinOn = not autoCoinOn
        setVisual(btnCoin, autoCoinOn, "Auto Coin: ")
    elseif input.KeyCode == Enum.KeyCode.RightControl then
        autoFinishOn = not autoFinishOn
        setVisual(btnFinish, autoFinishOn, "Auto Finish: ")
    end
end)

-- ========= Loops =========
task.spawn(function()
    while true do
        if autoCoinOn then doAutoCoinStep() end
        task.wait(0.1)
    end
end)

task.spawn(function()
    while true do
        if autoFinishOn then doAutoFinishCycle() end
        task.wait(0.1)
    end
end)
